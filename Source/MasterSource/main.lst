CCS PCM C Compiler, Version 4.065, 7924               08-Out-08 14:15

               Filename: main.lst

               ROM used: 3021 words (37%)
                         Largest free fragment is 2048
               RAM used: 56 (15%) at main() level
                         79 (21%) worst case
               Stack:    7 worst case (5 in main + 2 for interrupts)

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   19C
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  MOVLW  8C
001A:  MOVWF  04
001B:  BTFSS  00.5
001C:  GOTO   01F
001D:  BTFSC  0C.5
001E:  GOTO   032
001F:  MOVF   22,W
0020:  MOVWF  04
0021:  MOVF   23,W
0022:  MOVWF  77
0023:  MOVF   24,W
0024:  MOVWF  78
0025:  MOVF   25,W
0026:  MOVWF  79
0027:  MOVF   26,W
0028:  MOVWF  7A
0029:  MOVF   27,W
002A:  MOVWF  7B
002B:  MOVF   20,W
002C:  MOVWF  0A
002D:  SWAPF  21,W
002E:  MOVWF  03
002F:  SWAPF  7F,F
0030:  SWAPF  7F,W
0031:  RETFIE
0032:  BCF    0A.3
0033:  BCF    0A.4
0034:  GOTO   244
.................... #include <16f877a.h>                    
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,PUT,NOLVP  
.................... #device adc=8                           //  A/D  de 10 bits ou 8 a defenir 
.................... #use delay (clock=4000000)                 
*
02D3:  MOVLW  56
02D4:  MOVWF  04
02D5:  BCF    03.7
02D6:  MOVF   00,W
02D7:  BTFSC  03.2
02D8:  GOTO   2E7
02D9:  MOVLW  01
02DA:  MOVWF  78
02DB:  CLRF   77
02DC:  DECFSZ 77,F
02DD:  GOTO   2DC
02DE:  DECFSZ 78,F
02DF:  GOTO   2DB
02E0:  MOVLW  4A
02E1:  MOVWF  77
02E2:  DECFSZ 77,F
02E3:  GOTO   2E2
02E4:  GOTO   2E5
02E5:  DECFSZ 00,F
02E6:  GOTO   2D9
02E7:  RETLW  00
.................... #include <flex_lcd.c> 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_b4  
.................... #define LCD_DB5   PIN_b5  
.................... #define LCD_DB6   PIN_b6  
.................... #define LCD_DB7   PIN_b7  
....................  
.................... #define LCD_RS    PIN_b1  
.................... #define LCD_RW    PIN_b2  
.................... #define LCD_E     PIN_b0  
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... #define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
....................  
.................... //========================================  
....................  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
0316:  BTFSC  5D.0
0317:  GOTO   31A
0318:  BCF    06.4
0319:  GOTO   31B
031A:  BSF    06.4
031B:  BSF    03.5
031C:  BCF    06.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
031D:  BCF    03.5
031E:  BTFSC  5D.1
031F:  GOTO   322
0320:  BCF    06.5
0321:  GOTO   323
0322:  BSF    06.5
0323:  BSF    03.5
0324:  BCF    06.5
....................  output_bit(LCD_DB6, !!(nibble & 4));     
0325:  BCF    03.5
0326:  BTFSC  5D.2
0327:  GOTO   32A
0328:  BCF    06.6
0329:  GOTO   32B
032A:  BSF    06.6
032B:  BSF    03.5
032C:  BCF    06.6
....................  output_bit(LCD_DB7, !!(nibble & 8));     
032D:  BCF    03.5
032E:  BTFSC  5D.3
032F:  GOTO   332
0330:  BCF    06.7
0331:  GOTO   333
0332:  BSF    06.7
0333:  BSF    03.5
0334:  BCF    06.7
....................  
....................  delay_cycles(1);  
0335:  NOP
....................  output_high(LCD_E);  
0336:  BCF    06.0
0337:  BCF    03.5
0338:  BSF    06.0
....................  delay_us(2);  
0339:  GOTO   33A
....................  output_low(LCD_E);  
033A:  BSF    03.5
033B:  BCF    06.0
033C:  BCF    03.5
033D:  BCF    06.0
.................... }  
033E:  RETLW  00
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
033F:  CLRF   5E
....................      
.................... output_high(LCD_E);  
0340:  BSF    03.5
0341:  BCF    06.0
0342:  BCF    03.5
0343:  BSF    06.0
.................... delay_us(1);  
0344:  NOP
....................  
.................... retval_0 = input(LCD_DB4);  
0345:  BSF    03.5
0346:  BSF    06.4
0347:  BCF    03.5
0348:  BCF    5E.0
0349:  BTFSC  06.4
034A:  BSF    5E.0
.................... retval_1 = input(LCD_DB5);  
034B:  BSF    03.5
034C:  BSF    06.5
034D:  BCF    03.5
034E:  BCF    5E.1
034F:  BTFSC  06.5
0350:  BSF    5E.1
.................... retval_2 = input(LCD_DB6);  
0351:  BSF    03.5
0352:  BSF    06.6
0353:  BCF    03.5
0354:  BCF    5E.2
0355:  BTFSC  06.6
0356:  BSF    5E.2
.................... retval_3 = input(LCD_DB7);  
0357:  BSF    03.5
0358:  BSF    06.7
0359:  BCF    03.5
035A:  BCF    5E.3
035B:  BTFSC  06.7
035C:  BSF    5E.3
....................    
.................... output_low(LCD_E);  
035D:  BSF    03.5
035E:  BCF    06.0
035F:  BCF    03.5
0360:  BCF    06.0
.................... delay_us(1);  
0361:  NOP
....................      
.................... return(retval);     
0362:  MOVF   5E,W
0363:  MOVWF  78
.................... }     
0364:  RETLW  00
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
*
0369:  BSF    03.5
036A:  BCF    06.2
036B:  BCF    03.5
036C:  BSF    06.2
.................... delay_cycles(1);  
036D:  NOP
....................  
.................... high = lcd_read_nibble();  
036E:  CALL   33F
036F:  MOVF   78,W
0370:  MOVWF  5D
....................  
.................... low = lcd_read_nibble();  
0371:  CALL   33F
0372:  MOVF   78,W
0373:  MOVWF  5C
....................  
.................... return( (high<<4) | low);  
0374:  SWAPF  5D,W
0375:  MOVWF  77
0376:  MOVLW  F0
0377:  ANDWF  77,F
0378:  MOVF   77,W
0379:  IORWF  5C,W
037A:  MOVWF  78
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
*
0365:  BSF    03.5
0366:  BCF    06.1
0367:  BCF    03.5
0368:  BCF    06.1
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
*
037B:  MOVF   78,W
037C:  MOVWF  5C
037D:  BTFSC  5C.7
037E:  GOTO   369
.................... #else  
.................... delay_us(60);   
.................... #endif  
....................  
.................... if(address)  
037F:  MOVF   5A,F
0380:  BTFSC  03.2
0381:  GOTO   387
....................    output_high(LCD_RS);  
0382:  BSF    03.5
0383:  BCF    06.1
0384:  BCF    03.5
0385:  BSF    06.1
.................... else  
0386:  GOTO   38B
....................    output_low(LCD_RS);  
0387:  BSF    03.5
0388:  BCF    06.1
0389:  BCF    03.5
038A:  BCF    06.1
....................        
....................  delay_cycles(1);  
038B:  NOP
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
038C:  BSF    03.5
038D:  BCF    06.2
038E:  BCF    03.5
038F:  BCF    06.2
.................... delay_cycles(1);  
0390:  NOP
.................... #endif  
....................  
.................... output_low(LCD_E);  
0391:  BSF    03.5
0392:  BCF    06.0
0393:  BCF    03.5
0394:  BCF    06.0
....................  
.................... lcd_send_nibble(n >> 4);  
0395:  SWAPF  5B,W
0396:  MOVWF  5C
0397:  MOVLW  0F
0398:  ANDWF  5C,F
0399:  MOVF   5C,W
039A:  MOVWF  5D
039B:  CALL   316
.................... lcd_send_nibble(n & 0xf);  
039C:  MOVF   5B,W
039D:  ANDLW  0F
039E:  MOVWF  5C
039F:  MOVWF  5D
03A0:  CALL   316
.................... }  
03A1:  RETLW  00
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
.................... int8 i;  
....................  
.................... lcd_line = 1;  
*
03F0:  MOVLW  01
03F1:  MOVWF  28
....................  
.................... output_low(LCD_RS);  
03F2:  BSF    03.5
03F3:  BCF    06.1
03F4:  BCF    03.5
03F5:  BCF    06.1
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
03F6:  BSF    03.5
03F7:  BCF    06.2
03F8:  BCF    03.5
03F9:  BCF    06.2
.................... #endif  
....................  
.................... output_low(LCD_E);  
03FA:  BSF    03.5
03FB:  BCF    06.0
03FC:  BCF    03.5
03FD:  BCF    06.0
....................  
.................... // Some LCDs require 15 ms minimum delay after  
.................... // power-up.  Others require 30 ms.  I'm going  
.................... // to set it to 35 ms, so it should work with  
.................... // all of them.  
.................... delay_ms(35);           
03FE:  MOVLW  23
03FF:  MOVWF  56
0400:  CALL   2D3
....................  
.................... for(i=0 ;i < 3; i++)  
0401:  CLRF   4E
0402:  MOVF   4E,W
0403:  SUBLW  02
0404:  BTFSS  03.0
0405:  GOTO   40E
....................    {  
....................     lcd_send_nibble(0x03);  
0406:  MOVLW  03
0407:  MOVWF  5D
0408:  CALL   316
....................     delay_ms(5);  
0409:  MOVLW  05
040A:  MOVWF  56
040B:  CALL   2D3
....................    }  
040C:  INCF   4E,F
040D:  GOTO   402
....................  
.................... lcd_send_nibble(0x02);  
040E:  MOVLW  02
040F:  MOVWF  5D
0410:  CALL   316
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
0411:  CLRF   4E
0412:  MOVF   4E,W
0413:  SUBLW  03
0414:  BTFSS  03.0
0415:  GOTO   41F
....................    {  
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);  
0416:  MOVF   4E,W
0417:  CALL   035
0418:  MOVWF  4F
0419:  CLRF   5A
041A:  MOVF   4F,W
041B:  MOVWF  5B
041C:  CALL   365
....................      
....................     // If the R/W signal is not used, then  
....................     // the busy bit can't be polled.  One of  
....................     // the init commands takes longer than  
....................     // the hard-coded delay of 50 us, so in  
....................     // that case, lets just do a 5 ms delay  
....................     // after all four of them.  
....................     #ifndef USE_RW_PIN  
....................     delay_ms(5);  
....................     #endif  
....................    }  
041D:  INCF   4E,F
041E:  GOTO   412
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
....................   {  
*
03A2:  MOVF   57,W
03A3:  XORLW  01
03A4:  BTFSC  03.2
03A5:  GOTO   3B0
03A6:  XORLW  03
03A7:  BTFSC  03.2
03A8:  GOTO   3B2
03A9:  XORLW  01
03AA:  BTFSC  03.2
03AB:  GOTO   3B5
03AC:  XORLW  07
03AD:  BTFSC  03.2
03AE:  GOTO   3B8
03AF:  GOTO   3BB
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
03B0:  CLRF   58
....................      break;  
03B1:  GOTO   3BD
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
03B2:  MOVLW  40
03B3:  MOVWF  58
....................      break;  
03B4:  GOTO   3BD
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
03B5:  MOVLW  14
03B6:  MOVWF  58
....................      break;  
03B7:  GOTO   3BD
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
03B8:  MOVLW  54
03B9:  MOVWF  58
....................      break;  
03BA:  GOTO   3BD
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
03BB:  CLRF   58
....................      break;  
03BC:  GOTO   3BD
....................        
....................   }  
....................  
.................... address += x-1;  
03BD:  MOVLW  01
03BE:  SUBWF  56,W
03BF:  ADDWF  58,F
.................... lcd_send_byte(0, 0x80 | address);  
03C0:  MOVF   58,W
03C1:  IORLW  80
03C2:  MOVWF  59
03C3:  CLRF   5A
03C4:  MOVF   59,W
03C5:  MOVWF  5B
03C6:  CALL   365
.................... }  
03C7:  RETLW  00
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
....................    {  
03C8:  MOVF   55,W
03C9:  XORLW  0C
03CA:  BTFSC  03.2
03CB:  GOTO   3D3
03CC:  XORLW  06
03CD:  BTFSC  03.2
03CE:  GOTO   3DD
03CF:  XORLW  02
03D0:  BTFSC  03.2
03D1:  GOTO   3E4
03D2:  GOTO   3E9
....................     case '\f':  
....................       lcd_send_byte(0,1);  
03D3:  CLRF   5A
03D4:  MOVLW  01
03D5:  MOVWF  5B
03D6:  CALL   365
....................       lcd_line = 1;  
03D7:  MOVLW  01
03D8:  MOVWF  28
....................       delay_ms(2);  
03D9:  MOVLW  02
03DA:  MOVWF  56
03DB:  CALL   2D3
....................       break;  
03DC:  GOTO   3EF
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
03DD:  INCF   28,F
03DE:  MOVLW  01
03DF:  MOVWF  56
03E0:  MOVF   28,W
03E1:  MOVWF  57
03E2:  CALL   3A2
....................        break;  
03E3:  GOTO   3EF
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
03E4:  CLRF   5A
03E5:  MOVLW  10
03E6:  MOVWF  5B
03E7:  CALL   365
....................        break;  
03E8:  GOTO   3EF
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
03E9:  MOVLW  01
03EA:  MOVWF  5A
03EB:  MOVF   55,W
03EC:  MOVWF  5B
03ED:  CALL   365
....................        break;  
03EE:  GOTO   3EF
....................    }  
.................... }  
03EF:  RETLW  00
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
09AF:  BCF    03.5
09B0:  CLRF   29
09B1:  CLRF   2A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h>                      // Necessario para funcao atol ou atoi 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0135:  CLRF   65
....................    sign = 0; 
0136:  CLRF   63
....................    base = 10; 
0137:  MOVLW  0A
0138:  MOVWF  64
....................    result = 0; 
0139:  CLRF   62
....................  
....................    if (!s) 
013A:  MOVF   60,W
013B:  IORWF  61,W
013C:  BTFSS  03.2
013D:  GOTO   141
....................       return 0; 
013E:  MOVLW  00
013F:  MOVWF  78
0140:  GOTO   232
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0141:  MOVF   65,W
0142:  INCF   65,F
0143:  ADDWF  60,W
0144:  MOVWF  04
0145:  BCF    03.7
0146:  BTFSC  61.0
0147:  BSF    03.7
0148:  MOVF   00,W
0149:  MOVWF  66
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
014A:  MOVF   66,W
014B:  SUBLW  2D
014C:  BTFSS  03.2
014D:  GOTO   15A
....................    { 
....................       sign = 1;         // Set the sign to negative 
014E:  MOVLW  01
014F:  MOVWF  63
....................       c = s[index++]; 
0150:  MOVF   65,W
0151:  INCF   65,F
0152:  ADDWF  60,W
0153:  MOVWF  04
0154:  BCF    03.7
0155:  BTFSC  61.0
0156:  BSF    03.7
0157:  MOVF   00,W
0158:  MOVWF  66
....................    } 
....................    else if (c == '+') 
0159:  GOTO   167
015A:  MOVF   66,W
015B:  SUBLW  2B
015C:  BTFSS  03.2
015D:  GOTO   167
....................    { 
....................       c = s[index++]; 
015E:  MOVF   65,W
015F:  INCF   65,F
0160:  ADDWF  60,W
0161:  MOVWF  04
0162:  BCF    03.7
0163:  BTFSC  61.0
0164:  BSF    03.7
0165:  MOVF   00,W
0166:  MOVWF  66
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0167:  MOVF   66,W
0168:  SUBLW  2F
0169:  BTFSC  03.0
016A:  GOTO   228
016B:  MOVF   66,W
016C:  SUBLW  39
016D:  BTFSS  03.0
016E:  GOTO   228
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
016F:  MOVF   66,W
0170:  SUBLW  30
0171:  BTFSS  03.2
0172:  GOTO   193
0173:  MOVF   65,W
0174:  ADDWF  60,W
0175:  MOVWF  04
0176:  BCF    03.7
0177:  BTFSC  61.0
0178:  BSF    03.7
0179:  MOVF   00,W
017A:  SUBLW  78
017B:  BTFSC  03.2
017C:  GOTO   187
017D:  MOVF   65,W
017E:  ADDWF  60,W
017F:  MOVWF  04
0180:  BCF    03.7
0181:  BTFSC  61.0
0182:  BSF    03.7
0183:  MOVF   00,W
0184:  SUBLW  58
0185:  BTFSS  03.2
0186:  GOTO   193
....................       { 
....................          base = 16; 
0187:  MOVLW  10
0188:  MOVWF  64
....................          index++; 
0189:  INCF   65,F
....................          c = s[index++]; 
018A:  MOVF   65,W
018B:  INCF   65,F
018C:  ADDWF  60,W
018D:  MOVWF  04
018E:  BCF    03.7
018F:  BTFSC  61.0
0190:  BSF    03.7
0191:  MOVF   00,W
0192:  MOVWF  66
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0193:  MOVF   64,W
0194:  SUBLW  0A
0195:  BTFSS  03.2
0196:  GOTO   1D6
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0197:  MOVF   66,W
0198:  SUBLW  2F
0199:  BTFSC  03.0
019A:  GOTO   1D5
019B:  MOVF   66,W
019C:  SUBLW  39
019D:  BTFSS  03.0
019E:  GOTO   1D5
....................             result = 10*result + (c - '0'); 
019F:  MOVLW  0A
01A0:  MOVWF  67
01A1:  MOVF   62,W
01A2:  MOVWF  68
*
01C7:  MOVLW  30
01C8:  SUBWF  66,W
01C9:  ADDWF  78,W
01CA:  MOVWF  62
....................             c = s[index++]; 
01CB:  MOVF   65,W
01CC:  INCF   65,F
01CD:  ADDWF  60,W
01CE:  MOVWF  04
01CF:  BCF    03.7
01D0:  BTFSC  61.0
01D1:  BSF    03.7
01D2:  MOVF   00,W
01D3:  MOVWF  66
....................          } 
01D4:  GOTO   197
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
01D5:  GOTO   228
01D6:  MOVF   64,W
01D7:  SUBLW  10
01D8:  BTFSS  03.2
01D9:  GOTO   228
....................       { 
....................          c = toupper(c); 
01DA:  MOVF   66,W
01DB:  SUBLW  60
01DC:  BTFSC  03.0
01DD:  GOTO   1E5
01DE:  MOVF   66,W
01DF:  SUBLW  7A
01E0:  BTFSS  03.0
01E1:  GOTO   1E5
01E2:  MOVF   66,W
01E3:  ANDLW  DF
01E4:  GOTO   1E6
01E5:  MOVF   66,W
01E6:  MOVWF  66
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
01E7:  MOVF   66,W
01E8:  SUBLW  2F
01E9:  BTFSC  03.0
01EA:  GOTO   1EF
01EB:  MOVF   66,W
01EC:  SUBLW  39
01ED:  BTFSC  03.0
01EE:  GOTO   1F7
01EF:  MOVF   66,W
01F0:  SUBLW  40
01F1:  BTFSC  03.0
01F2:  GOTO   228
01F3:  MOVF   66,W
01F4:  SUBLW  46
01F5:  BTFSS  03.0
01F6:  GOTO   228
....................             if (c >= '0' && c <= '9') 
01F7:  MOVF   66,W
01F8:  SUBLW  2F
01F9:  BTFSC  03.0
01FA:  GOTO   208
01FB:  MOVF   66,W
01FC:  SUBLW  39
01FD:  BTFSS  03.0
01FE:  GOTO   208
....................                result = (result << 4) + (c - '0'); 
01FF:  SWAPF  62,W
0200:  MOVWF  67
0201:  MOVLW  F0
0202:  ANDWF  67,F
0203:  MOVLW  30
0204:  SUBWF  66,W
0205:  ADDWF  67,W
0206:  MOVWF  62
....................             else 
0207:  GOTO   211
....................                result = (result << 4) + (c - 'A' + 10); 
0208:  SWAPF  62,W
0209:  MOVWF  67
020A:  MOVLW  F0
020B:  ANDWF  67,F
020C:  MOVLW  41
020D:  SUBWF  66,W
020E:  ADDLW  0A
020F:  ADDWF  67,W
0210:  MOVWF  62
....................  
....................             c = s[index++]; 
0211:  MOVF   65,W
0212:  INCF   65,F
0213:  ADDWF  60,W
0214:  MOVWF  04
0215:  BCF    03.7
0216:  BTFSC  61.0
0217:  BSF    03.7
0218:  MOVF   00,W
0219:  MOVWF  66
....................             c = toupper(c); 
021A:  MOVF   66,W
021B:  SUBLW  60
021C:  BTFSC  03.0
021D:  GOTO   225
021E:  MOVF   66,W
021F:  SUBLW  7A
0220:  BTFSS  03.0
0221:  GOTO   225
0222:  MOVF   66,W
0223:  ANDLW  DF
0224:  GOTO   226
0225:  MOVF   66,W
0226:  MOVWF  66
....................          } 
0227:  GOTO   1E7
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0228:  DECFSZ 63,W
0229:  GOTO   230
022A:  MOVF   64,W
022B:  SUBLW  0A
022C:  BTFSS  03.2
022D:  GOTO   230
....................        result = -result; 
022E:  COMF   62,F
022F:  INCF   62,F
....................  
....................    return(result); 
0230:  MOVF   62,W
0231:  MOVWF  78
.................... } 
0232:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #use fast_io(C) 
.................... #use fast_io(B) 
.................... #use i2c(MASTER, SDA=PIN_C4, SCL=PIN_C3) 
*
04D8:  MOVLW  08
04D9:  MOVWF  78
04DA:  NOP
04DB:  BCF    07.3
04DC:  BSF    03.5
04DD:  BCF    07.3
04DE:  NOP
04DF:  BCF    03.5
04E0:  RLF    4E,F
04E1:  BCF    07.4
04E2:  BTFSS  03.0
04E3:  GOTO   4E7
04E4:  BSF    03.5
04E5:  BSF    07.4
04E6:  BCF    03.5
04E7:  BTFSC  03.0
04E8:  GOTO   4EC
04E9:  BSF    03.5
04EA:  BCF    07.4
04EB:  BCF    03.5
04EC:  BSF    03.5
04ED:  BSF    07.3
04EE:  BCF    03.5
04EF:  BTFSS  07.3
04F0:  GOTO   4EF
04F1:  DECFSZ 78,F
04F2:  GOTO   4DA
04F3:  NOP
04F4:  BCF    07.3
04F5:  BSF    03.5
04F6:  BCF    07.3
04F7:  NOP
04F8:  BSF    07.4
04F9:  NOP
04FA:  NOP
04FB:  BSF    07.3
04FC:  BCF    03.5
04FD:  BTFSS  07.3
04FE:  GOTO   4FD
04FF:  CLRF   78
0500:  NOP
0501:  BTFSC  07.4
0502:  BSF    78.0
0503:  BCF    07.3
0504:  BSF    03.5
0505:  BCF    07.3
0506:  BCF    03.5
0507:  BCF    07.4
0508:  BSF    03.5
0509:  BCF    07.4
050A:  BCF    03.5
050B:  RETLW  00
*
06FE:  MOVLW  08
06FF:  MOVWF  4F
0700:  MOVF   77,W
0701:  MOVWF  50
0702:  BSF    03.5
0703:  BSF    07.4
0704:  NOP
0705:  BSF    07.3
0706:  BCF    03.5
0707:  BTFSS  07.3
0708:  GOTO   707
0709:  BTFSC  07.4
070A:  BSF    03.0
070B:  BTFSS  07.4
070C:  BCF    03.0
070D:  RLF    78,F
070E:  NOP
070F:  BSF    03.5
0710:  BCF    07.3
0711:  BCF    03.5
0712:  BCF    07.3
0713:  DECFSZ 4F,F
0714:  GOTO   702
0715:  BSF    03.5
0716:  BSF    07.4
0717:  NOP
0718:  BCF    03.5
0719:  BCF    07.4
071A:  MOVF   50,W
071B:  BTFSC  03.2
071C:  GOTO   720
071D:  BSF    03.5
071E:  BCF    07.4
071F:  BCF    03.5
0720:  NOP
0721:  BSF    03.5
0722:  BSF    07.3
0723:  BCF    03.5
0724:  BTFSS  07.3
0725:  GOTO   724
0726:  NOP
0727:  BCF    07.3
0728:  BSF    03.5
0729:  BCF    07.3
072A:  NOP
072B:  BCF    03.5
072C:  BCF    07.4
072D:  BSF    03.5
072E:  BCF    07.4
072F:  BCF    03.5
0730:  RETLW  00
.................... #use rs232(baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7, bits=8,stream=rs232) 
....................  
.................... // Defenioes de Pinos 
.................... #define led_rs_on    output_low(PIN_D0)  // Indicador Actividade Uart 
.................... #define led_rs_off  output_high(PIN_D0) 
....................  
.................... #define led_spp_on  output_low(PIN_D1)  // Indicador Actividade I2c 
.................... #define led_spp_off output_high(PIN_D1) 
....................  
.................... // Defenioes De Rom 
....................  
.................... #define lenbuff 5                   // Comprimento Buffer Rs - Alterar tamanho se necessario 
....................  
....................  
.................... // Variaveis em Ram 
.................... int buffer_adc[6]  = {128,128,128,128,128,128};        // Buffer inciados com valor medio        
*
09B2:  MOVLW  80
09B3:  MOVWF  2F
09B4:  MOVWF  30
09B5:  MOVWF  31
09B6:  MOVWF  32
09B7:  MOVWF  33
09B8:  MOVWF  34
.................... int buffer_cpu[6]  = {128,128,128,128,128,128}; 
09B9:  MOVWF  35
09BA:  MOVWF  36
09BB:  MOVWF  37
09BC:  MOVWF  38
09BD:  MOVWF  39
09BE:  MOVWF  3A
.................... int buffer_mano[6] = {128,128,128,128,128,128}; 
09BF:  MOVWF  3B
09C0:  MOVWF  3C
09C1:  MOVWF  3D
09C2:  MOVWF  3E
09C3:  MOVWF  3F
09C4:  MOVWF  40
....................  
....................  
.................... char rs_buffer[lenbuff];            // Buffer Uart 
.................... char x=0; 
09C5:  CLRF   46
.................... char y=0; 
09C6:  CLRF   47
.................... char canal; 
.................... char index = 0x00;                // Index Buffer 
09C7:  CLRF   49
.................... char flag_request =0x00;                  //  Flag control 
09C8:  CLRF   4A
.................... // Declaracao Funcoes 
....................  
.................... void escreve_spp_mano(void); 
.................... void escreve_spp_cpu(void); 
.................... void ler_spp(void); 
.................... void inicbuff(void); 
.................... void chose_arm(); 
.................... void ini(); 
.................... void analog_config(); 
.................... void serial_isr(); 
.................... void show_mano(); 
.................... void show_cpu(); 
.................... void show_adc(); 
.................... void select_cpu(); 
.................... void send_cpu(char cu); 
....................  
.................... void inicbuff(void)                // Funao limpar Rs_Buffer 
....................  { 
....................    char i; 
....................    for(i=0;i<6;i++)            
*
0233:  CLRF   60
0234:  MOVF   60,W
0235:  SUBLW  05
0236:  BTFSS  03.0
0237:  GOTO   23F
....................    { 
....................       rs_buffer[i]=0x00;            // Limpo posicoes   
0238:  MOVLW  41
0239:  ADDWF  60,W
023A:  MOVWF  04
023B:  BCF    03.7
023C:  CLRF   00
....................    } 
023D:  INCF   60,F
023E:  GOTO   234
....................    index=0x00;                      // Inicializo index 
023F:  CLRF   49
....................    enable_interrupts(int_rda);      // Hablito interrupao rs 
0240:  BSF    03.5
0241:  BSF    0C.5
....................  } 
0242:  BCF    03.5
0243:  RETLW  00
....................  
.................... void escreve_spp_mano(void) 
.................... {       
....................       led_spp_on; 
*
050C:  BSF    03.5
050D:  BCF    08.1
050E:  BCF    03.5
050F:  BCF    08.1
....................       i2c_start (); 
0510:  BSF    03.5
0511:  BSF    07.4
0512:  NOP
0513:  BSF    07.3
0514:  NOP
0515:  BCF    03.5
0516:  BCF    07.4
0517:  BSF    03.5
0518:  BCF    07.4
0519:  NOP
051A:  BCF    03.5
051B:  BCF    07.3
051C:  BSF    03.5
051D:  BCF    07.3
....................       i2c_write (0xA0); 
051E:  MOVLW  A0
051F:  BCF    03.5
0520:  MOVWF  4E
0521:  CALL   4D8
....................       i2c_write (buffer_mano[0]);  
0522:  MOVF   3B,W
0523:  MOVWF  4E
0524:  CALL   4D8
....................       i2c_stop(); 
0525:  BSF    03.5
0526:  BCF    07.4
0527:  NOP
0528:  BSF    07.3
0529:  BCF    03.5
052A:  BTFSS  07.3
052B:  GOTO   52A
052C:  NOP
052D:  GOTO   52E
052E:  NOP
052F:  BSF    03.5
0530:  BSF    07.4
0531:  NOP
....................       led_spp_off; 
0532:  BCF    08.1
0533:  BCF    03.5
0534:  BSF    08.1
....................        
....................       led_spp_on; 
0535:  BSF    03.5
0536:  BCF    08.1
0537:  BCF    03.5
0538:  BCF    08.1
....................       i2c_start (); 
0539:  BSF    03.5
053A:  BSF    07.4
053B:  NOP
053C:  BSF    07.3
053D:  NOP
053E:  BCF    03.5
053F:  BCF    07.4
0540:  BSF    03.5
0541:  BCF    07.4
0542:  NOP
0543:  BCF    03.5
0544:  BCF    07.3
0545:  BSF    03.5
0546:  BCF    07.3
....................       i2c_write (0xA2); 
0547:  MOVLW  A2
0548:  BCF    03.5
0549:  MOVWF  4E
054A:  CALL   4D8
....................       i2c_write (buffer_mano[1]);  
054B:  MOVF   3C,W
054C:  MOVWF  4E
054D:  CALL   4D8
....................       i2c_stop(); 
054E:  BSF    03.5
054F:  BCF    07.4
0550:  NOP
0551:  BSF    07.3
0552:  BCF    03.5
0553:  BTFSS  07.3
0554:  GOTO   553
0555:  NOP
0556:  GOTO   557
0557:  NOP
0558:  BSF    03.5
0559:  BSF    07.4
055A:  NOP
....................       led_spp_off; 
055B:  BCF    08.1
055C:  BCF    03.5
055D:  BSF    08.1
....................        
....................       led_spp_on; 
055E:  BSF    03.5
055F:  BCF    08.1
0560:  BCF    03.5
0561:  BCF    08.1
....................       i2c_start (); 
0562:  BSF    03.5
0563:  BSF    07.4
0564:  NOP
0565:  BSF    07.3
0566:  NOP
0567:  BCF    03.5
0568:  BCF    07.4
0569:  BSF    03.5
056A:  BCF    07.4
056B:  NOP
056C:  BCF    03.5
056D:  BCF    07.3
056E:  BSF    03.5
056F:  BCF    07.3
....................       i2c_write (0xA4); 
0570:  MOVLW  A4
0571:  BCF    03.5
0572:  MOVWF  4E
0573:  CALL   4D8
....................       i2c_write (buffer_mano[2]);  
0574:  MOVF   3D,W
0575:  MOVWF  4E
0576:  CALL   4D8
....................       i2c_stop(); 
0577:  BSF    03.5
0578:  BCF    07.4
0579:  NOP
057A:  BSF    07.3
057B:  BCF    03.5
057C:  BTFSS  07.3
057D:  GOTO   57C
057E:  NOP
057F:  GOTO   580
0580:  NOP
0581:  BSF    03.5
0582:  BSF    07.4
0583:  NOP
....................       led_spp_off; 
0584:  BCF    08.1
0585:  BCF    03.5
0586:  BSF    08.1
....................        
....................       led_spp_on; 
0587:  BSF    03.5
0588:  BCF    08.1
0589:  BCF    03.5
058A:  BCF    08.1
....................       i2c_start (); 
058B:  BSF    03.5
058C:  BSF    07.4
058D:  NOP
058E:  BSF    07.3
058F:  NOP
0590:  BCF    03.5
0591:  BCF    07.4
0592:  BSF    03.5
0593:  BCF    07.4
0594:  NOP
0595:  BCF    03.5
0596:  BCF    07.3
0597:  BSF    03.5
0598:  BCF    07.3
....................       i2c_write (0xA6); 
0599:  MOVLW  A6
059A:  BCF    03.5
059B:  MOVWF  4E
059C:  CALL   4D8
....................       i2c_write (buffer_mano[3]);  
059D:  MOVF   3E,W
059E:  MOVWF  4E
059F:  CALL   4D8
....................       i2c_stop(); 
05A0:  BSF    03.5
05A1:  BCF    07.4
05A2:  NOP
05A3:  BSF    07.3
05A4:  BCF    03.5
05A5:  BTFSS  07.3
05A6:  GOTO   5A5
05A7:  NOP
05A8:  GOTO   5A9
05A9:  NOP
05AA:  BSF    03.5
05AB:  BSF    07.4
05AC:  NOP
....................       led_spp_off; 
05AD:  BCF    08.1
05AE:  BCF    03.5
05AF:  BSF    08.1
....................        
....................       led_spp_on; 
05B0:  BSF    03.5
05B1:  BCF    08.1
05B2:  BCF    03.5
05B3:  BCF    08.1
....................       i2c_start (); 
05B4:  BSF    03.5
05B5:  BSF    07.4
05B6:  NOP
05B7:  BSF    07.3
05B8:  NOP
05B9:  BCF    03.5
05BA:  BCF    07.4
05BB:  BSF    03.5
05BC:  BCF    07.4
05BD:  NOP
05BE:  BCF    03.5
05BF:  BCF    07.3
05C0:  BSF    03.5
05C1:  BCF    07.3
....................       i2c_write (0xA8); 
05C2:  MOVLW  A8
05C3:  BCF    03.5
05C4:  MOVWF  4E
05C5:  CALL   4D8
....................       i2c_write (buffer_mano[4]);  
05C6:  MOVF   3F,W
05C7:  MOVWF  4E
05C8:  CALL   4D8
....................       i2c_stop(); 
05C9:  BSF    03.5
05CA:  BCF    07.4
05CB:  NOP
05CC:  BSF    07.3
05CD:  BCF    03.5
05CE:  BTFSS  07.3
05CF:  GOTO   5CE
05D0:  NOP
05D1:  GOTO   5D2
05D2:  NOP
05D3:  BSF    03.5
05D4:  BSF    07.4
05D5:  NOP
....................       led_spp_off; 
05D6:  BCF    08.1
05D7:  BCF    03.5
05D8:  BSF    08.1
....................        
....................       led_spp_on; 
05D9:  BSF    03.5
05DA:  BCF    08.1
05DB:  BCF    03.5
05DC:  BCF    08.1
....................       i2c_start (); 
05DD:  BSF    03.5
05DE:  BSF    07.4
05DF:  NOP
05E0:  BSF    07.3
05E1:  NOP
05E2:  BCF    03.5
05E3:  BCF    07.4
05E4:  BSF    03.5
05E5:  BCF    07.4
05E6:  NOP
05E7:  BCF    03.5
05E8:  BCF    07.3
05E9:  BSF    03.5
05EA:  BCF    07.3
....................       i2c_write (0xAA); 
05EB:  MOVLW  AA
05EC:  BCF    03.5
05ED:  MOVWF  4E
05EE:  CALL   4D8
....................       i2c_write (buffer_mano[5]);  
05EF:  MOVF   40,W
05F0:  MOVWF  4E
05F1:  CALL   4D8
....................       i2c_stop(); 
05F2:  BSF    03.5
05F3:  BCF    07.4
05F4:  NOP
05F5:  BSF    07.3
05F6:  BCF    03.5
05F7:  BTFSS  07.3
05F8:  GOTO   5F7
05F9:  NOP
05FA:  GOTO   5FB
05FB:  NOP
05FC:  BSF    03.5
05FD:  BSF    07.4
05FE:  NOP
....................       led_spp_off; 
05FF:  BCF    08.1
0600:  BCF    03.5
0601:  BSF    08.1
....................  } 
0602:  BSF    0A.3
0603:  BCF    0A.4
0604:  GOTO   2B7 (RETURN)
....................  
.................... void escreve_spp_cpu(void) 
.................... {       
....................       led_spp_on; 
0605:  BSF    03.5
0606:  BCF    08.1
0607:  BCF    03.5
0608:  BCF    08.1
....................       i2c_start (); 
0609:  BSF    03.5
060A:  BSF    07.4
060B:  NOP
060C:  BSF    07.3
060D:  NOP
060E:  BCF    03.5
060F:  BCF    07.4
0610:  BSF    03.5
0611:  BCF    07.4
0612:  NOP
0613:  BCF    03.5
0614:  BCF    07.3
0615:  BSF    03.5
0616:  BCF    07.3
....................       i2c_write (0xA0); 
0617:  MOVLW  A0
0618:  BCF    03.5
0619:  MOVWF  4E
061A:  CALL   4D8
....................       i2c_write (buffer_cpu[0]);  
061B:  MOVF   35,W
061C:  MOVWF  4E
061D:  CALL   4D8
....................       i2c_stop(); 
061E:  BSF    03.5
061F:  BCF    07.4
0620:  NOP
0621:  BSF    07.3
0622:  BCF    03.5
0623:  BTFSS  07.3
0624:  GOTO   623
0625:  NOP
0626:  GOTO   627
0627:  NOP
0628:  BSF    03.5
0629:  BSF    07.4
062A:  NOP
....................       led_spp_off; 
062B:  BCF    08.1
062C:  BCF    03.5
062D:  BSF    08.1
....................        
....................       led_spp_on; 
062E:  BSF    03.5
062F:  BCF    08.1
0630:  BCF    03.5
0631:  BCF    08.1
....................       i2c_start (); 
0632:  BSF    03.5
0633:  BSF    07.4
0634:  NOP
0635:  BSF    07.3
0636:  NOP
0637:  BCF    03.5
0638:  BCF    07.4
0639:  BSF    03.5
063A:  BCF    07.4
063B:  NOP
063C:  BCF    03.5
063D:  BCF    07.3
063E:  BSF    03.5
063F:  BCF    07.3
....................       i2c_write (0xA2); 
0640:  MOVLW  A2
0641:  BCF    03.5
0642:  MOVWF  4E
0643:  CALL   4D8
....................       i2c_write (buffer_cpu[1]);  
0644:  MOVF   36,W
0645:  MOVWF  4E
0646:  CALL   4D8
....................       i2c_stop(); 
0647:  BSF    03.5
0648:  BCF    07.4
0649:  NOP
064A:  BSF    07.3
064B:  BCF    03.5
064C:  BTFSS  07.3
064D:  GOTO   64C
064E:  NOP
064F:  GOTO   650
0650:  NOP
0651:  BSF    03.5
0652:  BSF    07.4
0653:  NOP
....................       led_spp_off; 
0654:  BCF    08.1
0655:  BCF    03.5
0656:  BSF    08.1
....................        
....................       led_spp_on; 
0657:  BSF    03.5
0658:  BCF    08.1
0659:  BCF    03.5
065A:  BCF    08.1
....................       i2c_start (); 
065B:  BSF    03.5
065C:  BSF    07.4
065D:  NOP
065E:  BSF    07.3
065F:  NOP
0660:  BCF    03.5
0661:  BCF    07.4
0662:  BSF    03.5
0663:  BCF    07.4
0664:  NOP
0665:  BCF    03.5
0666:  BCF    07.3
0667:  BSF    03.5
0668:  BCF    07.3
....................       i2c_write (0xA4); 
0669:  MOVLW  A4
066A:  BCF    03.5
066B:  MOVWF  4E
066C:  CALL   4D8
....................       i2c_write (buffer_cpu[2]);  
066D:  MOVF   37,W
066E:  MOVWF  4E
066F:  CALL   4D8
....................       i2c_stop(); 
0670:  BSF    03.5
0671:  BCF    07.4
0672:  NOP
0673:  BSF    07.3
0674:  BCF    03.5
0675:  BTFSS  07.3
0676:  GOTO   675
0677:  NOP
0678:  GOTO   679
0679:  NOP
067A:  BSF    03.5
067B:  BSF    07.4
067C:  NOP
....................       led_spp_off; 
067D:  BCF    08.1
067E:  BCF    03.5
067F:  BSF    08.1
....................        
....................       led_spp_on; 
0680:  BSF    03.5
0681:  BCF    08.1
0682:  BCF    03.5
0683:  BCF    08.1
....................       i2c_start (); 
0684:  BSF    03.5
0685:  BSF    07.4
0686:  NOP
0687:  BSF    07.3
0688:  NOP
0689:  BCF    03.5
068A:  BCF    07.4
068B:  BSF    03.5
068C:  BCF    07.4
068D:  NOP
068E:  BCF    03.5
068F:  BCF    07.3
0690:  BSF    03.5
0691:  BCF    07.3
....................       i2c_write (0xA6); 
0692:  MOVLW  A6
0693:  BCF    03.5
0694:  MOVWF  4E
0695:  CALL   4D8
....................       i2c_write (buffer_cpu[3]);  
0696:  MOVF   38,W
0697:  MOVWF  4E
0698:  CALL   4D8
....................       i2c_stop(); 
0699:  BSF    03.5
069A:  BCF    07.4
069B:  NOP
069C:  BSF    07.3
069D:  BCF    03.5
069E:  BTFSS  07.3
069F:  GOTO   69E
06A0:  NOP
06A1:  GOTO   6A2
06A2:  NOP
06A3:  BSF    03.5
06A4:  BSF    07.4
06A5:  NOP
....................       led_spp_off; 
06A6:  BCF    08.1
06A7:  BCF    03.5
06A8:  BSF    08.1
....................        
....................       led_spp_on; 
06A9:  BSF    03.5
06AA:  BCF    08.1
06AB:  BCF    03.5
06AC:  BCF    08.1
....................       i2c_start (); 
06AD:  BSF    03.5
06AE:  BSF    07.4
06AF:  NOP
06B0:  BSF    07.3
06B1:  NOP
06B2:  BCF    03.5
06B3:  BCF    07.4
06B4:  BSF    03.5
06B5:  BCF    07.4
06B6:  NOP
06B7:  BCF    03.5
06B8:  BCF    07.3
06B9:  BSF    03.5
06BA:  BCF    07.3
....................       i2c_write (0xA8); 
06BB:  MOVLW  A8
06BC:  BCF    03.5
06BD:  MOVWF  4E
06BE:  CALL   4D8
....................       i2c_write (buffer_cpu[4]);  
06BF:  MOVF   39,W
06C0:  MOVWF  4E
06C1:  CALL   4D8
....................       i2c_stop(); 
06C2:  BSF    03.5
06C3:  BCF    07.4
06C4:  NOP
06C5:  BSF    07.3
06C6:  BCF    03.5
06C7:  BTFSS  07.3
06C8:  GOTO   6C7
06C9:  NOP
06CA:  GOTO   6CB
06CB:  NOP
06CC:  BSF    03.5
06CD:  BSF    07.4
06CE:  NOP
....................       led_spp_off; 
06CF:  BCF    08.1
06D0:  BCF    03.5
06D1:  BSF    08.1
....................        
....................       led_spp_on; 
06D2:  BSF    03.5
06D3:  BCF    08.1
06D4:  BCF    03.5
06D5:  BCF    08.1
....................       i2c_start (); 
06D6:  BSF    03.5
06D7:  BSF    07.4
06D8:  NOP
06D9:  BSF    07.3
06DA:  NOP
06DB:  BCF    03.5
06DC:  BCF    07.4
06DD:  BSF    03.5
06DE:  BCF    07.4
06DF:  NOP
06E0:  BCF    03.5
06E1:  BCF    07.3
06E2:  BSF    03.5
06E3:  BCF    07.3
....................       i2c_write (0xAA); 
06E4:  MOVLW  AA
06E5:  BCF    03.5
06E6:  MOVWF  4E
06E7:  CALL   4D8
....................       i2c_write (buffer_cpu[5]);  
06E8:  MOVF   3A,W
06E9:  MOVWF  4E
06EA:  CALL   4D8
....................       i2c_stop(); 
06EB:  BSF    03.5
06EC:  BCF    07.4
06ED:  NOP
06EE:  BSF    07.3
06EF:  BCF    03.5
06F0:  BTFSS  07.3
06F1:  GOTO   6F0
06F2:  NOP
06F3:  GOTO   6F4
06F4:  NOP
06F5:  BSF    03.5
06F6:  BSF    07.4
06F7:  NOP
....................       led_spp_off; 
06F8:  BCF    08.1
06F9:  BCF    03.5
06FA:  BSF    08.1
....................  } 
06FB:  BSF    0A.3
06FC:  BCF    0A.4
06FD:  GOTO   2BC (RETURN)
....................   
....................  void ler_spp(void) 
.................... {       
....................       led_spp_on; 
*
0800:  BSF    03.5
0801:  BCF    08.1
0802:  BCF    03.5
0803:  BCF    08.1
....................       i2c_start (); 
0804:  BSF    03.5
0805:  BSF    07.4
0806:  NOP
0807:  BSF    07.3
0808:  NOP
0809:  BCF    03.5
080A:  BCF    07.4
080B:  BSF    03.5
080C:  BCF    07.4
080D:  NOP
080E:  BCF    03.5
080F:  BCF    07.3
0810:  BSF    03.5
0811:  BCF    07.3
....................       i2c_write (0xA1); 
0812:  MOVLW  A1
0813:  BCF    03.5
0814:  MOVWF  4E
0815:  BCF    0A.3
0816:  CALL   4D8
0817:  BSF    0A.3
....................       buffer_adc[0]=i2c_read(0);  
0818:  CLRF   77
0819:  BCF    0A.3
081A:  CALL   6FE
081B:  BSF    0A.3
081C:  MOVF   78,W
081D:  MOVWF  2F
....................       i2c_stop(); 
081E:  BSF    03.5
081F:  BCF    07.4
0820:  NOP
0821:  BSF    07.3
0822:  BCF    03.5
0823:  BTFSS  07.3
0824:  GOTO   023
0825:  NOP
0826:  GOTO   027
0827:  NOP
0828:  BSF    03.5
0829:  BSF    07.4
082A:  NOP
....................       led_spp_off; 
082B:  BCF    08.1
082C:  BCF    03.5
082D:  BSF    08.1
....................        
....................       led_spp_on; 
082E:  BSF    03.5
082F:  BCF    08.1
0830:  BCF    03.5
0831:  BCF    08.1
....................       i2c_start (); 
0832:  BSF    03.5
0833:  BSF    07.4
0834:  NOP
0835:  BSF    07.3
0836:  NOP
0837:  BCF    03.5
0838:  BCF    07.4
0839:  BSF    03.5
083A:  BCF    07.4
083B:  NOP
083C:  BCF    03.5
083D:  BCF    07.3
083E:  BSF    03.5
083F:  BCF    07.3
....................       i2c_write (0xA3); 
0840:  MOVLW  A3
0841:  BCF    03.5
0842:  MOVWF  4E
0843:  BCF    0A.3
0844:  CALL   4D8
0845:  BSF    0A.3
....................       buffer_adc[1]=i2c_read(0);  
0846:  CLRF   77
0847:  BCF    0A.3
0848:  CALL   6FE
0849:  BSF    0A.3
084A:  MOVF   78,W
084B:  MOVWF  30
....................       i2c_stop(); 
084C:  BSF    03.5
084D:  BCF    07.4
084E:  NOP
084F:  BSF    07.3
0850:  BCF    03.5
0851:  BTFSS  07.3
0852:  GOTO   051
0853:  NOP
0854:  GOTO   055
0855:  NOP
0856:  BSF    03.5
0857:  BSF    07.4
0858:  NOP
....................       led_spp_off; 
0859:  BCF    08.1
085A:  BCF    03.5
085B:  BSF    08.1
....................        
....................       led_spp_on; 
085C:  BSF    03.5
085D:  BCF    08.1
085E:  BCF    03.5
085F:  BCF    08.1
....................       i2c_start (); 
0860:  BSF    03.5
0861:  BSF    07.4
0862:  NOP
0863:  BSF    07.3
0864:  NOP
0865:  BCF    03.5
0866:  BCF    07.4
0867:  BSF    03.5
0868:  BCF    07.4
0869:  NOP
086A:  BCF    03.5
086B:  BCF    07.3
086C:  BSF    03.5
086D:  BCF    07.3
....................       i2c_write (0xA5); 
086E:  MOVLW  A5
086F:  BCF    03.5
0870:  MOVWF  4E
0871:  BCF    0A.3
0872:  CALL   4D8
0873:  BSF    0A.3
....................       buffer_adc[2]=i2c_read(0);  
0874:  CLRF   77
0875:  BCF    0A.3
0876:  CALL   6FE
0877:  BSF    0A.3
0878:  MOVF   78,W
0879:  MOVWF  31
....................       i2c_stop(); 
087A:  BSF    03.5
087B:  BCF    07.4
087C:  NOP
087D:  BSF    07.3
087E:  BCF    03.5
087F:  BTFSS  07.3
0880:  GOTO   07F
0881:  NOP
0882:  GOTO   083
0883:  NOP
0884:  BSF    03.5
0885:  BSF    07.4
0886:  NOP
....................       led_spp_off; 
0887:  BCF    08.1
0888:  BCF    03.5
0889:  BSF    08.1
....................        
....................       led_spp_on; 
088A:  BSF    03.5
088B:  BCF    08.1
088C:  BCF    03.5
088D:  BCF    08.1
....................       i2c_start (); 
088E:  BSF    03.5
088F:  BSF    07.4
0890:  NOP
0891:  BSF    07.3
0892:  NOP
0893:  BCF    03.5
0894:  BCF    07.4
0895:  BSF    03.5
0896:  BCF    07.4
0897:  NOP
0898:  BCF    03.5
0899:  BCF    07.3
089A:  BSF    03.5
089B:  BCF    07.3
....................       i2c_write (0xA7); 
089C:  MOVLW  A7
089D:  BCF    03.5
089E:  MOVWF  4E
089F:  BCF    0A.3
08A0:  CALL   4D8
08A1:  BSF    0A.3
....................       buffer_adc[3]=i2c_read(0);  
08A2:  CLRF   77
08A3:  BCF    0A.3
08A4:  CALL   6FE
08A5:  BSF    0A.3
08A6:  MOVF   78,W
08A7:  MOVWF  32
....................       i2c_stop(); 
08A8:  BSF    03.5
08A9:  BCF    07.4
08AA:  NOP
08AB:  BSF    07.3
08AC:  BCF    03.5
08AD:  BTFSS  07.3
08AE:  GOTO   0AD
08AF:  NOP
08B0:  GOTO   0B1
08B1:  NOP
08B2:  BSF    03.5
08B3:  BSF    07.4
08B4:  NOP
....................       led_spp_off; 
08B5:  BCF    08.1
08B6:  BCF    03.5
08B7:  BSF    08.1
....................        
....................       led_spp_on; 
08B8:  BSF    03.5
08B9:  BCF    08.1
08BA:  BCF    03.5
08BB:  BCF    08.1
....................       i2c_start (); 
08BC:  BSF    03.5
08BD:  BSF    07.4
08BE:  NOP
08BF:  BSF    07.3
08C0:  NOP
08C1:  BCF    03.5
08C2:  BCF    07.4
08C3:  BSF    03.5
08C4:  BCF    07.4
08C5:  NOP
08C6:  BCF    03.5
08C7:  BCF    07.3
08C8:  BSF    03.5
08C9:  BCF    07.3
....................       i2c_write (0xA9); 
08CA:  MOVLW  A9
08CB:  BCF    03.5
08CC:  MOVWF  4E
08CD:  BCF    0A.3
08CE:  CALL   4D8
08CF:  BSF    0A.3
....................       buffer_adc[4]=i2c_read(0);  
08D0:  CLRF   77
08D1:  BCF    0A.3
08D2:  CALL   6FE
08D3:  BSF    0A.3
08D4:  MOVF   78,W
08D5:  MOVWF  33
....................       i2c_stop(); 
08D6:  BSF    03.5
08D7:  BCF    07.4
08D8:  NOP
08D9:  BSF    07.3
08DA:  BCF    03.5
08DB:  BTFSS  07.3
08DC:  GOTO   0DB
08DD:  NOP
08DE:  GOTO   0DF
08DF:  NOP
08E0:  BSF    03.5
08E1:  BSF    07.4
08E2:  NOP
....................       led_spp_off; 
08E3:  BCF    08.1
08E4:  BCF    03.5
08E5:  BSF    08.1
....................        
....................       led_spp_on; 
08E6:  BSF    03.5
08E7:  BCF    08.1
08E8:  BCF    03.5
08E9:  BCF    08.1
....................       i2c_start (); 
08EA:  BSF    03.5
08EB:  BSF    07.4
08EC:  NOP
08ED:  BSF    07.3
08EE:  NOP
08EF:  BCF    03.5
08F0:  BCF    07.4
08F1:  BSF    03.5
08F2:  BCF    07.4
08F3:  NOP
08F4:  BCF    03.5
08F5:  BCF    07.3
08F6:  BSF    03.5
08F7:  BCF    07.3
....................       i2c_write (0xAB); 
08F8:  MOVLW  AB
08F9:  BCF    03.5
08FA:  MOVWF  4E
08FB:  BCF    0A.3
08FC:  CALL   4D8
08FD:  BSF    0A.3
....................       buffer_adc[5]=i2c_read(0);  
08FE:  CLRF   77
08FF:  BCF    0A.3
0900:  CALL   6FE
0901:  BSF    0A.3
0902:  MOVF   78,W
0903:  MOVWF  34
....................       i2c_stop(); 
0904:  BSF    03.5
0905:  BCF    07.4
0906:  NOP
0907:  BSF    07.3
0908:  BCF    03.5
0909:  BTFSS  07.3
090A:  GOTO   109
090B:  NOP
090C:  GOTO   10D
090D:  NOP
090E:  BSF    03.5
090F:  BSF    07.4
0910:  NOP
....................       led_spp_off; 
0911:  BCF    08.1
0912:  BCF    03.5
0913:  BSF    08.1
....................  } 
0914:  BSF    0A.3
0915:  BCF    0A.4
0916:  GOTO   2BE (RETURN)
....................  
.................... // Interrupcao 
.................... #int_rda                            // Funcao lidar com interrupcao 
....................   void serial_isr()                 // para recepcao da Uart 
....................   { 
....................    char c; 
....................    led_rs_on;                       // Indicador actividade da Uart 
*
0244:  BSF    03.5
0245:  BCF    08.0
0246:  BCF    03.5
0247:  BCF    08.0
....................    if(kbhit())                      // Comprobo se existe bit de "start para a Uart 
0248:  BTFSS  0C.5
0249:  GOTO   2CB
....................    { 
....................      c = getc(); 
024A:  BTFSS  0C.5
024B:  GOTO   24A
024C:  MOVF   1A,W
024D:  MOVWF  5F
....................      if ( c == '|'){ 
024E:  MOVF   5F,W
024F:  SUBLW  7C
0250:  BTFSS  03.2
0251:  GOTO   2C0
....................          rs_buffer[index]= c;          // Puxo caracter para buffer 
0252:  MOVLW  41
0253:  ADDWF  49,W
0254:  MOVWF  04
0255:  BCF    03.7
0256:  MOVF   5F,W
0257:  MOVWF  00
....................          disable_interrupts(int_rda);  // Desbilito rda 
0258:  BSF    03.5
0259:  BCF    0C.5
....................          chose_arm();                  // Chamo funao  
....................          }  
....................       else if ( index <lenbuff){ 
*
02BF:  GOTO   2CB
02C0:  MOVF   49,W
02C1:  SUBLW  04
02C2:  BTFSS  03.0
02C3:  GOTO   2CB
....................          rs_buffer[index++]= c;   
02C4:  MOVF   49,W
02C5:  INCF   49,F
02C6:  ADDLW  41
02C7:  MOVWF  04
02C8:  BCF    03.7
02C9:  MOVF   5F,W
02CA:  MOVWF  00
....................          } 
....................    } 
....................    led_rs_off;                           // fim de actividade 
02CB:  BSF    03.5
02CC:  BCF    08.0
02CD:  BCF    03.5
02CE:  BSF    08.0
.................... } 
....................  
02CF:  BCF    0C.5
02D0:  BCF    0A.3
02D1:  BCF    0A.4
02D2:  GOTO   01F
.................... void chose_arm(void) 
.................... { 
....................  
....................    switch (rs_buffer[3]) 
....................    { 
*
025A:  BCF    03.5
025B:  MOVF   44,W
025C:  XORLW  61
025D:  BTFSC  03.2
025E:  GOTO   272
025F:  XORLW  03
0260:  BTFSC  03.2
0261:  GOTO   27E
0262:  XORLW  01
0263:  BTFSC  03.2
0264:  GOTO   28A
0265:  XORLW  07
0266:  BTFSC  03.2
0267:  GOTO   296
0268:  XORLW  01
0269:  BTFSC  03.2
026A:  GOTO   2A2
026B:  XORLW  03
026C:  BTFSC  03.2
026D:  GOTO   2AE
026E:  XORLW  0C
026F:  BTFSC  03.2
0270:  GOTO   2BA
0271:  GOTO   2BE
....................       case 'a': 
....................          if (rs_buffer[0]=='s'){ 
0272:  MOVF   41,W
0273:  SUBLW  73
0274:  BTFSC  03.2
....................          // stop_arm(buffer_rs[3]; 
....................          } 
....................          else{ 
0275:  GOTO   27D
....................          buffer_cpu[0] = atoi(rs_buffer); 
0276:  CLRF   61
0277:  MOVLW  41
0278:  MOVWF  60
0279:  CALL   135
027A:  MOVF   78,W
027B:  MOVWF  35
....................          inicbuff(); 
027C:  CALL   233
....................          } 
....................       break; 
027D:  GOTO   2BF
....................       case 'b': 
....................          if (rs_buffer[0]=='s'){ 
027E:  MOVF   41,W
027F:  SUBLW  73
0280:  BTFSC  03.2
....................          // stop_arm(buffer_rs[3]; 
....................          } 
....................          else{ 
0281:  GOTO   289
....................          buffer_cpu[1] = atoi(rs_buffer); 
0282:  CLRF   61
0283:  MOVLW  41
0284:  MOVWF  60
0285:  CALL   135
0286:  MOVF   78,W
0287:  MOVWF  36
....................          inicbuff(); 
0288:  CALL   233
....................          } 
....................       break; 
0289:  GOTO   2BF
....................       case 'c': 
....................          if (rs_buffer[0]=='s'){ 
028A:  MOVF   41,W
028B:  SUBLW  73
028C:  BTFSC  03.2
....................          // stop_arm(buffer_rs[3]; 
....................          } 
....................          else{ 
028D:  GOTO   295
....................          buffer_cpu[2] = atoi(rs_buffer); 
028E:  CLRF   61
028F:  MOVLW  41
0290:  MOVWF  60
0291:  CALL   135
0292:  MOVF   78,W
0293:  MOVWF  37
....................          inicbuff(); 
0294:  CALL   233
....................          } 
....................       break; 
0295:  GOTO   2BF
....................       case 'd': 
....................          if (rs_buffer[0]=='s'){ 
0296:  MOVF   41,W
0297:  SUBLW  73
0298:  BTFSC  03.2
....................          // stop_arm(buffer_rs[3]; 
....................          } 
....................          else{ 
0299:  GOTO   2A1
....................          buffer_cpu[3] = atoi(rs_buffer); 
029A:  CLRF   61
029B:  MOVLW  41
029C:  MOVWF  60
029D:  CALL   135
029E:  MOVF   78,W
029F:  MOVWF  38
....................          inicbuff(); 
02A0:  CALL   233
....................          } 
....................       break; 
02A1:  GOTO   2BF
....................       case 'e': 
....................          if (rs_buffer[0]=='s'){ 
02A2:  MOVF   41,W
02A3:  SUBLW  73
02A4:  BTFSC  03.2
....................          // stop_arm(buffer_rs[3]; 
....................          } 
....................          else{ 
02A5:  GOTO   2AD
....................          buffer_cpu[4] = atoi(rs_buffer); 
02A6:  CLRF   61
02A7:  MOVLW  41
02A8:  MOVWF  60
02A9:  CALL   135
02AA:  MOVF   78,W
02AB:  MOVWF  39
....................          inicbuff(); 
02AC:  CALL   233
....................          } 
....................       break; 
02AD:  GOTO   2BF
....................       case 'f': 
....................          if (rs_buffer[0]=='s'){ 
02AE:  MOVF   41,W
02AF:  SUBLW  73
02B0:  BTFSC  03.2
....................          // stop_arm(buffer_rs[3]; 
....................          } 
....................          else{ 
02B1:  GOTO   2B9
....................          buffer_cpu[5] = atoi(rs_buffer); 
02B2:  CLRF   61
02B3:  MOVLW  41
02B4:  MOVWF  60
02B5:  CALL   135
02B6:  MOVF   78,W
02B7:  MOVWF  3A
....................          inicbuff(); 
02B8:  CALL   233
....................          } 
....................       break; 
02B9:  GOTO   2BF
....................       case 'j': 
....................          { 
....................       inicbuff(); 
02BA:  CALL   233
....................       flag_request=1; 
02BB:  MOVLW  01
02BC:  MOVWF  4A
....................       } 
....................       break; 
02BD:  GOTO   2BF
....................       default: 
....................          inicbuff();   
02BE:  CALL   233
....................    }         
.................... } 
....................  
....................  
....................  
....................  
.................... void ini () 
.................... { 
....................  
....................    lcd_init();  
....................    delay_ms(2);       
*
041F:  MOVLW  02
0420:  MOVWF  56
0421:  CALL   2D3
....................    x=1;y=1; 
0422:  MOVLW  01
0423:  MOVWF  46
0424:  MOVWF  47
....................    lcd_gotoxy(x,y); 
0425:  MOVF   46,W
0426:  MOVWF  56
0427:  MOVF   47,W
0428:  MOVWF  57
0429:  CALL   3A2
....................    printf(lcd_putc,"     Hugo Soares  "); 
042A:  CLRF   4E
042B:  MOVF   4E,W
042C:  CALL   03D
042D:  INCF   4E,F
042E:  MOVWF  77
042F:  MOVWF  55
0430:  CALL   3C8
0431:  MOVLW  12
0432:  SUBWF  4E,W
0433:  BTFSS  03.2
0434:  GOTO   42B
....................    x=1;y=2; 
0435:  MOVLW  01
0436:  MOVWF  46
0437:  MOVLW  02
0438:  MOVWF  47
....................    lcd_gotoxy(x,y); 
0439:  MOVF   46,W
043A:  MOVWF  56
043B:  MOVF   47,W
043C:  MOVWF  57
043D:  CALL   3A2
....................    printf(lcd_putc,"  **  Apresenta  **"); 
043E:  CLRF   4E
043F:  MOVF   4E,W
0440:  CALL   054
0441:  INCF   4E,F
0442:  MOVWF  77
0443:  MOVWF  55
0444:  CALL   3C8
0445:  MOVLW  13
0446:  SUBWF  4E,W
0447:  BTFSS  03.2
0448:  GOTO   43F
....................    delay_ms(2000); 
0449:  MOVLW  08
044A:  MOVWF  4E
044B:  MOVLW  FA
044C:  MOVWF  56
044D:  CALL   2D3
044E:  DECFSZ 4E,F
044F:  GOTO   44B
....................    printf(lcd_putc,"\f" ) ;   
0450:  MOVLW  0C
0451:  MOVWF  55
0452:  CALL   3C8
....................    x=1;y=1; 
0453:  MOVLW  01
0454:  MOVWF  46
0455:  MOVWF  47
....................    lcd_gotoxy(x,y); 
0456:  MOVF   46,W
0457:  MOVWF  56
0458:  MOVF   47,W
0459:  MOVWF  57
045A:  CALL   3A2
....................    printf(lcd_putc,"    Robot Mentor   " ) ; 
045B:  CLRF   4E
045C:  MOVF   4E,W
045D:  CALL   072
045E:  INCF   4E,F
045F:  MOVWF  77
0460:  MOVWF  55
0461:  CALL   3C8
0462:  MOVLW  13
0463:  SUBWF  4E,W
0464:  BTFSS  03.2
0465:  GOTO   45C
....................    x=1;y=2; 
0466:  MOVLW  01
0467:  MOVWF  46
0468:  MOVLW  02
0469:  MOVWF  47
....................    lcd_gotoxy(x,y); 
046A:  MOVF   46,W
046B:  MOVWF  56
046C:  MOVF   47,W
046D:  MOVWF  57
046E:  CALL   3A2
....................    printf(lcd_putc,"********************" ) ; 
046F:  CLRF   4E
0470:  MOVF   4E,W
0471:  CALL   08A
0472:  INCF   4E,F
0473:  MOVWF  77
0474:  MOVWF  55
0475:  CALL   3C8
0476:  MOVLW  14
0477:  SUBWF  4E,W
0478:  BTFSS  03.2
0479:  GOTO   470
....................    delay_ms(2000); 
047A:  MOVLW  08
047B:  MOVWF  4E
047C:  MOVLW  FA
047D:  MOVWF  56
047E:  CALL   2D3
047F:  DECFSZ 4E,F
0480:  GOTO   47C
....................    lcd_putc("\f"); 
0481:  CLRF   4E
0482:  MOVF   4E,W
0483:  CALL   06C
0484:  IORLW  00
0485:  BTFSC  03.2
0486:  GOTO   48B
0487:  INCF   4E,F
0488:  MOVWF  55
0489:  CALL   3C8
048A:  GOTO   482
....................    x=1;y=1; 
048B:  MOVLW  01
048C:  MOVWF  46
048D:  MOVWF  47
....................    lcd_gotoxy(x,y); 
048E:  MOVF   46,W
048F:  MOVWF  56
0490:  MOVF   47,W
0491:  MOVWF  57
0492:  CALL   3A2
....................  
.................... } 
0493:  BSF    0A.3
0494:  BCF    0A.4
0495:  GOTO   1D2 (RETURN)
....................  
....................  
....................  
.................... void analog_config()          // Porto analogico 
.................... { 
.................... setup_adc_ports(an0); 
*
02E8:  BSF    03.5
02E9:  BCF    1F.0
02EA:  BSF    1F.1
02EB:  BSF    1F.2
02EC:  BSF    1F.3
.................... setup_adc(ADC_CLOCK_INTERNAL); 
02ED:  BCF    1F.6
02EE:  BCF    03.5
02EF:  BSF    1F.6
02F0:  BSF    1F.7
02F1:  BSF    03.5
02F2:  BCF    1F.7
02F3:  BCF    03.5
02F4:  BSF    1F.0
.................... set_tris_a(0b00000001); 
02F5:  MOVLW  01
02F6:  BSF    03.5
02F7:  MOVWF  05
.................... set_tris_b(0x00);  
02F8:  MOVLW  00
02F9:  MOVWF  06
.................... set_tris_c (0b10000000); 
02FA:  MOVLW  80
02FB:  MOVWF  07
.................... set_tris_d (0b11111100); 
02FC:  MOVLW  FC
02FD:  MOVWF  08
.................... led_rs_on; 
02FE:  BCF    08.0
02FF:  BCF    03.5
0300:  BCF    08.0
.................... led_spp_on; 
0301:  BSF    03.5
0302:  BCF    08.1
0303:  BCF    03.5
0304:  BCF    08.1
.................... delay_ms(200); 
0305:  MOVLW  C8
0306:  MOVWF  56
0307:  CALL   2D3
.................... enable_interrupts(global); 
0308:  MOVLW  C0
0309:  IORWF  0B,F
.................... enable_interrupts(int_rda); 
030A:  BSF    03.5
030B:  BSF    0C.5
....................  
.................... led_rs_off; 
030C:  BCF    08.0
030D:  BCF    03.5
030E:  BSF    08.0
.................... led_spp_off; 
030F:  BSF    03.5
0310:  BCF    08.1
0311:  BCF    03.5
0312:  BSF    08.1
.................... } 
0313:  BSF    0A.3
0314:  BCF    0A.4
0315:  GOTO   1CE (RETURN)
....................  
.................... void set_channel() 
.................... { 
.................... if (canal==0) 
*
0496:  MOVF   48,F
0497:  BTFSS  03.2
0498:  GOTO   49B
....................       { 
....................       output_c(0x00); 
0499:  CLRF   07
....................       } 
.................... else if (canal==1) 
049A:  GOTO   4BB
049B:  DECFSZ 48,W
049C:  GOTO   4A0
....................       { 
....................       output_c(0x01); 
049D:  MOVLW  01
049E:  MOVWF  07
....................       } 
.................... else if (canal==2) 
049F:  GOTO   4BB
04A0:  MOVF   48,W
04A1:  SUBLW  02
04A2:  BTFSS  03.2
04A3:  GOTO   4A7
....................       { 
....................       output_c(0x02); 
04A4:  MOVLW  02
04A5:  MOVWF  07
....................       } 
.................... else if (canal==3) 
04A6:  GOTO   4BB
04A7:  MOVF   48,W
04A8:  SUBLW  03
04A9:  BTFSS  03.2
04AA:  GOTO   4AE
....................       { 
....................       output_c(0x03); 
04AB:  MOVLW  03
04AC:  MOVWF  07
....................       } 
.................... else if (canal==4) 
04AD:  GOTO   4BB
04AE:  MOVF   48,W
04AF:  SUBLW  04
04B0:  BTFSS  03.2
04B1:  GOTO   4B5
....................       { 
....................       output_c(0x04); 
04B2:  MOVLW  04
04B3:  MOVWF  07
....................       } 
.................... else if (canal==5) 
04B4:  GOTO   4BB
04B5:  MOVF   48,W
04B6:  SUBLW  05
04B7:  BTFSS  03.2
04B8:  GOTO   4BB
....................       { 
....................       output_c(0x05); 
04B9:  MOVLW  05
04BA:  MOVWF  07
....................       } 
.................... } 
04BB:  BSF    0A.3
04BC:  BCF    0A.4
04BD:  GOTO   1DA (RETURN)
....................  
....................  
....................  
.................... void read_valor() 
.................... { 
.................... set_adc_channel(0); 
04BE:  MOVLW  00
04BF:  MOVWF  78
04C0:  MOVF   1F,W
04C1:  ANDLW  C7
04C2:  IORWF  78,W
04C3:  MOVWF  1F
.................... delay_us(10); 
04C4:  MOVLW  03
04C5:  MOVWF  77
04C6:  DECFSZ 77,F
04C7:  GOTO   4C6
.................... buffer_mano[canal]=read_adc(); 
04C8:  MOVLW  3B
04C9:  ADDWF  48,W
04CA:  MOVWF  04
04CB:  BCF    03.7
04CC:  BSF    1F.2
04CD:  BTFSC  1F.2
04CE:  GOTO   4CD
04CF:  MOVF   1E,W
04D0:  MOVWF  00
.................... delay_us(10); 
04D1:  MOVLW  03
04D2:  MOVWF  77
04D3:  DECFSZ 77,F
04D4:  GOTO   4D3
.................... } 
04D5:  BSF    0A.3
04D6:  BCF    0A.4
04D7:  GOTO   1DD (RETURN)
....................  
....................  
.................... void show_mano() 
.................... { 
.................... if (canal>2) 
*
0AE1:  MOVF   48,W
0AE2:  SUBLW  02
0AE3:  BTFSC  03.0
0AE4:  GOTO   2F0
....................    { 
....................    lcd_gotoxy(11,canal-1); 
0AE5:  MOVLW  01
0AE6:  SUBWF  48,W
0AE7:  MOVWF  4E
0AE8:  MOVLW  0B
0AE9:  MOVWF  56
0AEA:  MOVF   4E,W
0AEB:  MOVWF  57
0AEC:  BCF    0A.3
0AED:  CALL   3A2
0AEE:  BSF    0A.3
....................    } 
.................... else if(canal<=2) 
0AEF:  GOTO   2FE
0AF0:  MOVF   48,W
0AF1:  SUBLW  02
0AF2:  BTFSS  03.0
0AF3:  GOTO   2FE
....................    { 
....................    lcd_gotoxy(1,canal+2); 
0AF4:  MOVLW  02
0AF5:  ADDWF  48,W
0AF6:  MOVWF  4E
0AF7:  MOVLW  01
0AF8:  MOVWF  56
0AF9:  MOVF   4E,W
0AFA:  MOVWF  57
0AFB:  BCF    0A.3
0AFC:  CALL   3A2
0AFD:  BSF    0A.3
....................    } 
.................... delay_ms(20);               //Delay for wait lcd 
0AFE:  MOVLW  14
0AFF:  MOVWF  56
0B00:  BCF    0A.3
0B01:  CALL   2D3
0B02:  BSF    0A.3
.................... printf(lcd_putc,"C%d %3u",canal,buffer_mano[canal]); 
0B03:  MOVLW  3B
0B04:  ADDWF  48,W
0B05:  MOVWF  04
0B06:  BCF    03.7
0B07:  MOVF   00,W
0B08:  MOVWF  4E
0B09:  MOVLW  43
0B0A:  MOVWF  55
0B0B:  BCF    0A.3
0B0C:  CALL   3C8
0B0D:  BSF    0A.3
0B0E:  MOVF   48,W
0B0F:  MOVWF  4F
0B10:  MOVLW  1F
0B11:  MOVWF  50
0B12:  BCF    0A.3
0B13:  CALL   746
0B14:  BSF    0A.3
0B15:  MOVLW  20
0B16:  MOVWF  55
0B17:  BCF    0A.3
0B18:  CALL   3C8
0B19:  BSF    0A.3
0B1A:  MOVF   4E,W
0B1B:  MOVWF  4F
0B1C:  MOVLW  13
0B1D:  MOVWF  50
0B1E:  BCF    0A.3
0B1F:  CALL   7AB
0B20:  BSF    0A.3
.................... } 
....................  
....................  
.................... void show_cpu() 
.................... { 
.................... if (canal>2) 
*
0B43:  MOVF   48,W
0B44:  SUBLW  02
0B45:  BTFSC  03.0
0B46:  GOTO   352
....................    { 
....................    lcd_gotoxy(11,canal-1); 
0B47:  MOVLW  01
0B48:  SUBWF  48,W
0B49:  MOVWF  4E
0B4A:  MOVLW  0B
0B4B:  MOVWF  56
0B4C:  MOVF   4E,W
0B4D:  MOVWF  57
0B4E:  BCF    0A.3
0B4F:  CALL   3A2
0B50:  BSF    0A.3
....................    } 
.................... else if(canal<=2) 
0B51:  GOTO   360
0B52:  MOVF   48,W
0B53:  SUBLW  02
0B54:  BTFSS  03.0
0B55:  GOTO   360
....................    { 
....................    lcd_gotoxy(1,canal+2); 
0B56:  MOVLW  02
0B57:  ADDWF  48,W
0B58:  MOVWF  4E
0B59:  MOVLW  01
0B5A:  MOVWF  56
0B5B:  MOVF   4E,W
0B5C:  MOVWF  57
0B5D:  BCF    0A.3
0B5E:  CALL   3A2
0B5F:  BSF    0A.3
....................    } 
.................... delay_ms(2);               //Delay for wait lcd 
0B60:  MOVLW  02
0B61:  MOVWF  56
0B62:  BCF    0A.3
0B63:  CALL   2D3
0B64:  BSF    0A.3
.................... printf(lcd_putc,"C%d %3u",canal,buffer_cpu[canal]); 
0B65:  MOVLW  35
0B66:  ADDWF  48,W
0B67:  MOVWF  04
0B68:  BCF    03.7
0B69:  MOVF   00,W
0B6A:  MOVWF  4E
0B6B:  MOVLW  43
0B6C:  MOVWF  55
0B6D:  BCF    0A.3
0B6E:  CALL   3C8
0B6F:  BSF    0A.3
0B70:  MOVF   48,W
0B71:  MOVWF  4F
0B72:  MOVLW  1F
0B73:  MOVWF  50
0B74:  BCF    0A.3
0B75:  CALL   746
0B76:  BSF    0A.3
0B77:  MOVLW  20
0B78:  MOVWF  55
0B79:  BCF    0A.3
0B7A:  CALL   3C8
0B7B:  BSF    0A.3
0B7C:  MOVF   4E,W
0B7D:  MOVWF  4F
0B7E:  MOVLW  13
0B7F:  MOVWF  50
0B80:  BCF    0A.3
0B81:  CALL   7AB
0B82:  BSF    0A.3
.................... } 
....................  
....................  
.................... void show_adc() 
.................... { 
.................... if (canal>2) 
*
0BA5:  MOVF   48,W
0BA6:  SUBLW  02
0BA7:  BTFSC  03.0
0BA8:  GOTO   3B4
....................    { 
....................    lcd_gotoxy(11,canal-1); 
0BA9:  MOVLW  01
0BAA:  SUBWF  48,W
0BAB:  MOVWF  4E
0BAC:  MOVLW  0B
0BAD:  MOVWF  56
0BAE:  MOVF   4E,W
0BAF:  MOVWF  57
0BB0:  BCF    0A.3
0BB1:  CALL   3A2
0BB2:  BSF    0A.3
....................    } 
.................... else if(canal<=2) 
0BB3:  GOTO   3C2
0BB4:  MOVF   48,W
0BB5:  SUBLW  02
0BB6:  BTFSS  03.0
0BB7:  GOTO   3C2
....................    { 
....................    lcd_gotoxy(1,canal+2); 
0BB8:  MOVLW  02
0BB9:  ADDWF  48,W
0BBA:  MOVWF  4E
0BBB:  MOVLW  01
0BBC:  MOVWF  56
0BBD:  MOVF   4E,W
0BBE:  MOVWF  57
0BBF:  BCF    0A.3
0BC0:  CALL   3A2
0BC1:  BSF    0A.3
....................    } 
.................... delay_ms(2);               //Delay for wait lcd 
0BC2:  MOVLW  02
0BC3:  MOVWF  56
0BC4:  BCF    0A.3
0BC5:  CALL   2D3
0BC6:  BSF    0A.3
.................... printf(lcd_putc,"C%d %3u",canal,buffer_adc[canal]); 
0BC7:  MOVLW  2F
0BC8:  ADDWF  48,W
0BC9:  MOVWF  04
0BCA:  BCF    03.7
0BCB:  MOVF   00,W
0BCC:  MOVWF  4E
0BCD:  MOVLW  43
0BCE:  MOVWF  55
0BCF:  BCF    0A.3
0BD0:  CALL   3C8
0BD1:  BSF    0A.3
0BD2:  MOVF   48,W
0BD3:  MOVWF  4F
0BD4:  MOVLW  1F
0BD5:  MOVWF  50
0BD6:  BCF    0A.3
0BD7:  CALL   746
0BD8:  BSF    0A.3
0BD9:  MOVLW  20
0BDA:  MOVWF  55
0BDB:  BCF    0A.3
0BDC:  CALL   3C8
0BDD:  BSF    0A.3
0BDE:  MOVF   4E,W
0BDF:  MOVWF  4F
0BE0:  MOVLW  13
0BE1:  MOVWF  50
0BE2:  BCF    0A.3
0BE3:  CALL   7AB
0BE4:  BSF    0A.3
.................... } 
....................  
.................... void select_cpu() 
.................... { 
.................... disable_interrupts(int_rda); 
*
0964:  BSF    03.5
0965:  BCF    0C.5
.................... for (canal=0;canal<6;canal++) 
0966:  BCF    03.5
0967:  CLRF   48
0968:  MOVF   48,W
0969:  SUBLW  05
096A:  BTFSS  03.0
096B:  GOTO   18C
....................    { 
....................     
....................    switch(canal) 
....................       { 
096C:  MOVF   48,W
096D:  ADDLW  FA
096E:  BTFSC  03.0
096F:  GOTO   18A
0970:  ADDLW  06
0971:  GOTO   192
....................          case 0:send_cpu('a'); 
0972:  MOVLW  61
0973:  MOVWF  4E
0974:  CALL   117
....................          break; 
0975:  GOTO   18A
....................          case 1:send_cpu('b'); 
0976:  MOVLW  62
0977:  MOVWF  4E
0978:  CALL   117
....................          break; 
0979:  GOTO   18A
....................          case 2:send_cpu('c'); 
097A:  MOVLW  63
097B:  MOVWF  4E
097C:  CALL   117
....................          break; 
097D:  GOTO   18A
....................          case 3:send_cpu('d'); 
097E:  MOVLW  64
097F:  MOVWF  4E
0980:  CALL   117
....................          break; 
0981:  GOTO   18A
....................          case 4:send_cpu('e'); 
0982:  MOVLW  65
0983:  MOVWF  4E
0984:  CALL   117
....................          break; 
0985:  GOTO   18A
....................          case 5:send_cpu('f'); 
0986:  MOVLW  66
0987:  MOVWF  4E
0988:  CALL   117
....................          break; 
0989:  GOTO   18A
....................           
....................       }   
....................    } 
098A:  INCF   48,F
098B:  GOTO   168
.................... enable_interrupts(int_rda); 
098C:  BSF    03.5
098D:  BSF    0C.5
.................... } 
098E:  BCF    03.5
098F:  BSF    0A.3
0990:  BCF    0A.4
0991:  GOTO   3EA (RETURN)
....................  
.................... void send_cpu(char cu) 
.................... { 
.................... printf("%3u%c|",buffer_adc[canal],cu); 
*
0917:  MOVLW  2F
0918:  ADDWF  48,W
0919:  MOVWF  04
091A:  BCF    03.7
091B:  MOVF   00,W
091C:  MOVWF  4F
091D:  MOVF   4F,W
091E:  MOVWF  50
091F:  MOVLW  13
0920:  MOVWF  51
*
095B:  MOVF   4E,W
095C:  BTFSS  0C.4
095D:  GOTO   15C
095E:  MOVWF  19
095F:  MOVLW  7C
0960:  BTFSS  0C.4
0961:  GOTO   160
0962:  MOVWF  19
....................  
.................... } 
0963:  RETLW  00
....................  
.................... void main(void) 
....................  
.................... { 
*
099C:  CLRF   04
099D:  BCF    03.7
099E:  MOVLW  1F
099F:  ANDWF  03,F
09A0:  MOVLW  19
09A1:  BSF    03.5
09A2:  MOVWF  19
09A3:  MOVLW  A6
09A4:  MOVWF  18
09A5:  MOVLW  90
09A6:  BCF    03.5
09A7:  MOVWF  18
09A8:  BSF    03.5
09A9:  BSF    1F.0
09AA:  BSF    1F.1
09AB:  BSF    1F.2
09AC:  BCF    1F.3
09AD:  MOVLW  07
09AE:  MOVWF  1C
....................    int1 modo=0; 
*
09C9:  BCF    4B.0
....................    long tempo=0; 
09CA:  CLRF   4C
09CB:  CLRF   4D
....................    analog_config(); 
09CC:  BCF    0A.3
09CD:  GOTO   2E8
09CE:  BSF    0A.3
....................    canal=0; 
09CF:  CLRF   48
....................    ini(); 
09D0:  BCF    0A.3
09D1:  GOTO   3F0
09D2:  BSF    0A.3
....................    
....................     
....................    while(true) 
....................    { 
....................      for (canal=0;canal<6;canal++) 
09D3:  CLRF   48
09D4:  MOVF   48,W
09D5:  SUBLW  05
09D6:  BTFSS  03.0
09D7:  GOTO   1E0
....................          { 
....................          set_channel(); 
09D8:  BCF    0A.3
09D9:  GOTO   496
09DA:  BSF    0A.3
....................          read_valor();  
09DB:  BCF    0A.3
09DC:  GOTO   4BE
09DD:  BSF    0A.3
....................          } 
09DE:  INCF   48,F
09DF:  GOTO   1D4
....................           
....................      if(tempo>4800) 
09E0:  MOVF   4D,W
09E1:  SUBLW  11
09E2:  BTFSC  03.0
09E3:  GOTO   1ED
09E4:  XORLW  FF
09E5:  BTFSS  03.2
09E6:  GOTO   1EB
09E7:  MOVF   4C,W
09E8:  SUBLW  C0
09E9:  BTFSC  03.0
09EA:  GOTO   1ED
....................          { 
....................          tempo=0; 
09EB:  CLRF   4D
09EC:  CLRF   4C
....................          } 
....................           
....................       tempo++;  
09ED:  INCF   4C,F
09EE:  BTFSC  03.2
09EF:  INCF   4D,F
....................        
....................       if ((buffer_mano[0]!=0)&&(buffer_mano[1]!=0)&&(buffer_mano[2]!=0)&&(buffer_mano[3]!=0)&&(buffer_mano[4]!=0)&&(buffer_mano[5]!=0)&& (input(pin_d2)!=0)) 
09F0:  MOVF   3B,F
09F1:  BTFSC  03.2
09F2:  GOTO   208
09F3:  MOVF   3C,F
09F4:  BTFSC  03.2
09F5:  GOTO   208
09F6:  MOVF   3D,F
09F7:  BTFSC  03.2
09F8:  GOTO   208
09F9:  MOVF   3E,F
09FA:  BTFSC  03.2
09FB:  GOTO   208
09FC:  MOVF   3F,F
09FD:  BTFSC  03.2
09FE:  GOTO   208
09FF:  MOVF   40,F
0A00:  BTFSC  03.2
0A01:  GOTO   208
0A02:  BSF    03.5
0A03:  BSF    08.2
0A04:  BCF    03.5
0A05:  BTFSS  08.2
0A06:  GOTO   208
....................          { 
....................          modo =0; 
0A07:  BCF    4B.0
....................          } 
....................           
....................       if ((buffer_mano[0]==0)&&(buffer_mano[1]==0)&&(buffer_mano[2]==0)&&(buffer_mano[3]==0)&&(buffer_mano[4]==0)&&(buffer_mano[5]==0) | (input(pin_d2)==0)) 
0A08:  MOVF   3B,F
0A09:  BTFSS  03.2
0A0A:  GOTO   228
0A0B:  MOVF   3C,F
0A0C:  BTFSS  03.2
0A0D:  GOTO   228
0A0E:  MOVF   3D,F
0A0F:  BTFSS  03.2
0A10:  GOTO   228
0A11:  MOVF   3E,F
0A12:  BTFSS  03.2
0A13:  GOTO   228
0A14:  MOVF   3F,F
0A15:  BTFSS  03.2
0A16:  GOTO   228
0A17:  MOVF   40,F
0A18:  BTFSC  03.2
0A19:  GOTO   21C
0A1A:  MOVLW  00
0A1B:  GOTO   21D
0A1C:  MOVLW  01
0A1D:  MOVWF  4E
0A1E:  BSF    03.5
0A1F:  BSF    08.2
0A20:  MOVLW  00
0A21:  BCF    03.5
0A22:  BTFSS  08.2
0A23:  MOVLW  01
0A24:  IORWF  4E,W
0A25:  BTFSC  03.2
0A26:  GOTO   228
....................          { 
....................          modo=1; 
0A27:  BSF    4B.0
....................          } 
....................           
....................           
....................       if ((tempo==1)&&(modo==0)) 
0A28:  DECFSZ 4C,W
0A29:  GOTO   242
0A2A:  MOVF   4D,F
0A2B:  BTFSS  03.2
0A2C:  GOTO   242
0A2D:  BTFSC  4B.0
0A2E:  GOTO   242
....................          { 
....................          lcd_putc('\f'); 
0A2F:  MOVLW  0C
0A30:  MOVWF  55
0A31:  BCF    0A.3
0A32:  CALL   3C8
0A33:  BSF    0A.3
....................          lcd_putc(" Joystick Connected "); 
0A34:  CLRF   4E
0A35:  MOVF   4E,W
0A36:  BCF    0A.3
0A37:  CALL   0A3
0A38:  BSF    0A.3
0A39:  IORLW  00
0A3A:  BTFSC  03.2
0A3B:  GOTO   242
0A3C:  INCF   4E,F
0A3D:  MOVWF  55
0A3E:  BCF    0A.3
0A3F:  CALL   3C8
0A40:  BSF    0A.3
0A41:  GOTO   235
....................          } 
....................           
....................       if ((tempo ==1) && (modo==1)) 
0A42:  DECFSZ 4C,W
0A43:  GOTO   270
0A44:  MOVF   4D,F
0A45:  BTFSS  03.2
0A46:  GOTO   270
0A47:  BTFSS  4B.0
0A48:  GOTO   270
....................          { 
....................          lcd_putc('\f'); 
0A49:  MOVLW  0C
0A4A:  MOVWF  55
0A4B:  BCF    0A.3
0A4C:  CALL   3C8
0A4D:  BSF    0A.3
....................          if (input(pin_d2)==0) 
0A4E:  BSF    03.5
0A4F:  BSF    08.2
0A50:  BCF    03.5
0A51:  BTFSC  08.2
0A52:  GOTO   262
....................             { 
....................             lcd_putc("   Software Mode   "); 
0A53:  CLRF   4E
0A54:  MOVF   4E,W
0A55:  BCF    0A.3
0A56:  CALL   0BC
0A57:  BSF    0A.3
0A58:  IORLW  00
0A59:  BTFSC  03.2
0A5A:  GOTO   261
0A5B:  INCF   4E,F
0A5C:  MOVWF  55
0A5D:  BCF    0A.3
0A5E:  CALL   3C8
0A5F:  BSF    0A.3
0A60:  GOTO   254
....................             } 
....................          else 
0A61:  GOTO   270
....................             { 
....................             lcd_putc("     No Joystick   "); 
0A62:  CLRF   4E
0A63:  MOVF   4E,W
0A64:  BCF    0A.3
0A65:  CALL   0D4
0A66:  BSF    0A.3
0A67:  IORLW  00
0A68:  BTFSC  03.2
0A69:  GOTO   270
0A6A:  INCF   4E,F
0A6B:  MOVWF  55
0A6C:  BCF    0A.3
0A6D:  CALL   3C8
0A6E:  BSF    0A.3
0A6F:  GOTO   263
....................             } 
....................          }         
....................       if ((tempo==100) | (tempo==1200) | (tempo==2300) | (tempo==3400) | (tempo==4500)) 
0A70:  MOVF   4C,W
0A71:  SUBLW  64
0A72:  BTFSS  03.2
0A73:  GOTO   277
0A74:  MOVF   4D,F
0A75:  BTFSC  03.2
0A76:  GOTO   279
0A77:  MOVLW  00
0A78:  GOTO   27A
0A79:  MOVLW  01
0A7A:  MOVWF  4E
0A7B:  MOVF   4C,W
0A7C:  SUBLW  B0
0A7D:  BTFSS  03.2
0A7E:  GOTO   283
0A7F:  MOVF   4D,W
0A80:  SUBLW  04
0A81:  BTFSC  03.2
0A82:  GOTO   285
0A83:  MOVLW  00
0A84:  GOTO   286
0A85:  MOVLW  01
0A86:  IORWF  4E,W
0A87:  MOVWF  4F
0A88:  MOVF   4C,W
0A89:  SUBLW  FC
0A8A:  BTFSS  03.2
0A8B:  GOTO   290
0A8C:  MOVF   4D,W
0A8D:  SUBLW  08
0A8E:  BTFSC  03.2
0A8F:  GOTO   292
0A90:  MOVLW  00
0A91:  GOTO   293
0A92:  MOVLW  01
0A93:  IORWF  4F,W
0A94:  MOVWF  50
0A95:  MOVF   4C,W
0A96:  SUBLW  48
0A97:  BTFSS  03.2
0A98:  GOTO   29D
0A99:  MOVF   4D,W
0A9A:  SUBLW  0D
0A9B:  BTFSC  03.2
0A9C:  GOTO   29F
0A9D:  MOVLW  00
0A9E:  GOTO   2A0
0A9F:  MOVLW  01
0AA0:  IORWF  50,W
0AA1:  MOVWF  51
0AA2:  MOVF   4C,W
0AA3:  SUBLW  94
0AA4:  BTFSS  03.2
0AA5:  GOTO   2AA
0AA6:  MOVF   4D,W
0AA7:  SUBLW  11
0AA8:  BTFSC  03.2
0AA9:  GOTO   2AC
0AAA:  MOVLW  00
0AAB:  GOTO   2AD
0AAC:  MOVLW  01
0AAD:  IORWF  51,W
0AAE:  BTFSC  03.2
0AAF:  GOTO   2C1
....................          { 
....................          disable_interrupts(int_rda); 
0AB0:  BSF    03.5
0AB1:  BCF    0C.5
....................          if (modo==0) 
0AB2:  BCF    03.5
0AB3:  BTFSC  4B.0
0AB4:  GOTO   2B8
....................             { 
....................             escreve_spp_mano(); 
0AB5:  BCF    0A.3
0AB6:  GOTO   50C
0AB7:  BSF    0A.3
....................             } 
....................              
....................          if (modo==1) 
0AB8:  BTFSS  4B.0
0AB9:  GOTO   2BD
....................             { 
....................             escreve_spp_cpu(); 
0ABA:  BCF    0A.3
0ABB:  GOTO   605
0ABC:  BSF    0A.3
....................             } 
....................              
....................          ler_spp(); 
0ABD:  GOTO   000
....................          enable_interrupts(int_rda); 
0ABE:  BSF    03.5
0ABF:  BSF    0C.5
0AC0:  BCF    03.5
....................          } 
....................           
....................           
....................          if (tempo == 900) 
0AC1:  MOVF   4C,W
0AC2:  SUBLW  84
0AC3:  BTFSS  03.2
0AC4:  GOTO   323
0AC5:  MOVF   4D,W
0AC6:  SUBLW  03
0AC7:  BTFSS  03.2
0AC8:  GOTO   323
....................             { 
....................             lcd_putc('\f'); 
0AC9:  MOVLW  0C
0ACA:  MOVWF  55
0ACB:  BCF    0A.3
0ACC:  CALL   3C8
0ACD:  BSF    0A.3
....................             lcd_putc("   Posicao Manipulo "); 
0ACE:  CLRF   4E
0ACF:  MOVF   4E,W
0AD0:  BCF    0A.3
0AD1:  CALL   0EC
0AD2:  BSF    0A.3
0AD3:  IORLW  00
0AD4:  BTFSC  03.2
0AD5:  GOTO   2DC
0AD6:  INCF   4E,F
0AD7:  MOVWF  55
0AD8:  BCF    0A.3
0AD9:  CALL   3C8
0ADA:  BSF    0A.3
0ADB:  GOTO   2CF
....................             for (canal=0; canal<6;canal++) 
0ADC:  CLRF   48
0ADD:  MOVF   48,W
0ADE:  SUBLW  05
0ADF:  BTFSS  03.0
0AE0:  GOTO   323
....................                { 
....................                show_mano(); 
....................                } 
*
0B21:  INCF   48,F
0B22:  GOTO   2DD
....................             } 
....................          if (tempo == 1900) 
0B23:  MOVF   4C,W
0B24:  SUBLW  6C
0B25:  BTFSS  03.2
0B26:  GOTO   385
0B27:  MOVF   4D,W
0B28:  SUBLW  07
0B29:  BTFSS  03.2
0B2A:  GOTO   385
....................             { 
....................             lcd_putc('\f'); 
0B2B:  MOVLW  0C
0B2C:  MOVWF  55
0B2D:  BCF    0A.3
0B2E:  CALL   3C8
0B2F:  BSF    0A.3
....................             lcd_putc("   Posicao CPU  "); 
0B30:  CLRF   4E
0B31:  MOVF   4E,W
0B32:  BCF    0A.3
0B33:  CALL   108
0B34:  BSF    0A.3
0B35:  IORLW  00
0B36:  BTFSC  03.2
0B37:  GOTO   33E
0B38:  INCF   4E,F
0B39:  MOVWF  55
0B3A:  BCF    0A.3
0B3B:  CALL   3C8
0B3C:  BSF    0A.3
0B3D:  GOTO   331
....................             for (canal=0;canal<6;canal++) 
0B3E:  CLRF   48
0B3F:  MOVF   48,W
0B40:  SUBLW  05
0B41:  BTFSS  03.0
0B42:  GOTO   385
....................                { 
....................                show_cpu(); 
....................                } 
*
0B83:  INCF   48,F
0B84:  GOTO   33F
....................             } 
....................          if (tempo ==3900) 
0B85:  MOVF   4C,W
0B86:  SUBLW  3C
0B87:  BTFSS  03.2
0B88:  GOTO   3E7
0B89:  MOVF   4D,W
0B8A:  SUBLW  0F
0B8B:  BTFSS  03.2
0B8C:  GOTO   3E7
....................             { 
....................             lcd_putc('\f');  
0B8D:  MOVLW  0C
0B8E:  MOVWF  55
0B8F:  BCF    0A.3
0B90:  CALL   3C8
0B91:  BSF    0A.3
....................             lcd_putc("   Posicao Motores "); 
0B92:  CLRF   4E
0B93:  MOVF   4E,W
0B94:  BCF    0A.3
0B95:  CALL   11D
0B96:  BSF    0A.3
0B97:  IORLW  00
0B98:  BTFSC  03.2
0B99:  GOTO   3A0
0B9A:  INCF   4E,F
0B9B:  MOVWF  55
0B9C:  BCF    0A.3
0B9D:  CALL   3C8
0B9E:  BSF    0A.3
0B9F:  GOTO   393
....................             for (canal=0;canal<6;canal++) 
0BA0:  CLRF   48
0BA1:  MOVF   48,W
0BA2:  SUBLW  05
0BA3:  BTFSS  03.0
0BA4:  GOTO   3E7
....................                {        
....................                show_adc(); 
....................                } 
*
0BE5:  INCF   48,F
0BE6:  GOTO   3A1
....................             } 
....................          if (flag_request ==1) 
0BE7:  DECFSZ 4A,W
0BE8:  GOTO   3EB
....................             { 
....................             select_cpu(); 
0BE9:  GOTO   164
....................             flag_request=0; 
0BEA:  CLRF   4A
....................             } 
....................          
....................        } 
0BEB:  GOTO   1D3
....................    
....................    
....................   } 
....................     
....................  
0BEC:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
